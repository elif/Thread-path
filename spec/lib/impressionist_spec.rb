require 'spec_helper'
require 'chunky_png'
# require 'opencv' # Commented out as ruby-opencv is not installed
require 'impressionist' # Assuming lib is in $LOAD_PATH via spec_helper

# Helper to extend RSpec for describing implementations
module ImpressionistSpecHelpers
  def describe_implementations(implementations, &block)
    implementations.each do |impl|
      context "with #{impl} implementation" do
        instance_exec(impl, &block)
      end
    end
  end
end

RSpec.configure do |config|
  config.extend ImpressionistSpecHelpers
end

RSpec.describe Impressionist do
  let(:fixture_dir) { File.expand_path('../../fixtures', __FILE__) }
  let(:input_path) { File.join(fixture_dir, 'test_image.png') } # Using the 1x1 PNG from previous step
  let(:output_dir) { File.expand_path('../../../tmp/test_output', __FILE__) } # Temp output for this spec
  let(:output_path) { File.join(output_dir, 'output_impressionist.png') }

  before(:all) do
    # Ensure fixture_image.png exists (it's a 1x1 transparent PNG)
    # This should have been created by the app_integration_spec setup, but ensure it for standalone runs.
    fixture_png_path = File.join(File.expand_path('../../fixtures', __FILE__), 'test_image.png')
    unless File.exist?(fixture_png_path)
      FileUtils.mkdir_p(File.dirname(fixture_png_path))
      File.open(fixture_png_path, 'wb') do |f|
        f.write(Base64.decode64('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='))
      end
    end
  end

  before(:each) do
    FileUtils.mkdir_p(output_dir)
    FileUtils.rm_f(output_path) # Clean up output file before each test
  end

  after(:all) do
    FileUtils.rm_rf(File.expand_path('../../../tmp', __FILE__)) # Clean up all tmp content generated by specs
  end

  describe '.load_image' do
    it 'loads a PNG file' do
      expect { Impressionist.load_image(input_path) }.not_to raise_error
      img = Impressionist.load_image(input_path)
      expect(img).to be_a(ChunkyPNG::Image)
      expect(img.width).to eq(1)
      expect(img.height).to eq(1)
    end

    it 'raises an error if file not found' do
      expect { Impressionist.load_image('nonexistent.png') }.to raise_error(ArgumentError, /File not found/)
    end
  end

  describe '.save_image' do
    it 'saves a ChunkyPNG::Image to disk' do
      img = ChunkyPNG::Image.new(1, 1, ChunkyPNG::Color::BLACK)
      Impressionist.save_image(img, output_path)
      expect(File.exist?(output_path)).to be true
      loaded_img = ChunkyPNG::Image.from_file(output_path)
      expect(loaded_img[0,0]).to eq(ChunkyPNG::Color::BLACK)
    end
  end

  describe '.recolor' do
    it 'processes an image and saves it' do
      options = { quant_interval: 8 }
      expect(Impressionist.recolor(input_path, output_path, options)).to be true
      expect(File.exist?(output_path)).to be true
      # Basic check, more detailed checks in .process_image specs
      expect(ChunkyPNG::Image.from_file(output_path)).to be_a(ChunkyPNG::Image)
    end
  end

  describe '.process' do
    let(:options) { { quant_interval: 8 } }

    describe_implementations [:chunky_png, :opencv] do |implementation|
      # The 'context "with #{implementation} implementation" do' is now created by the helper
      it "processes an image and returns the expected structure for #{implementation}" do
        run_options = options.merge(implementation: implementation)
        result = Impressionist.process(input_path, run_options)

        expect(result).to have_key(:image)
        expect(result).to have_key(:labels)
        expect(result).to have_key(:blob_count)

        expect(result[:image]).to be_a(ChunkyPNG::Image)
        expect(result[:image].width).to be > 0
        expect(result[:image].height).to be > 0

        expect(result[:labels]).to be_an(Array)
        expect(result[:labels].size).to eq(result[:image].height)
        expect(result[:labels].first.size).to eq(result[:image].width)
        expect(result[:blob_count]).to be_an(Integer)
        expect(result[:blob_count]).to be >= 0
      end
    end

    # Test default behavior (chunky_png) when no implementation is specified
    context "with default (chunky_png) implementation" do
      it 'processes an image and returns a ChunkyPNG::Image based result' do
        result = Impressionist.process(input_path, options) # No implementation specified
        expect(result[:image]).to be_a(ChunkyPNG::Image)
        expect(result).to have_key(:labels)
        expect(result).to have_key(:blob_count)
        expect(result[:labels]).to be_an(Array)
        expect(result[:blob_count]).to be_an(Integer)
      end
    end
  end

  describe '.process_image' do
    let(:source_img) { ChunkyPNG::Image.new(2, 2, ChunkyPNG::Color.rgb(100, 150, 200)) }
    # For quantization test, use pixels that will quantize to the SAME color
    # to ensure a single blob, then check if the average of ORIGINALS is used.
    let(:quant_test_img) do
      img = ChunkyPNG::Image.new(2, 2)
      img[0,0] = ChunkyPNG::Color.rgb(10, 20, 30) # Q_16: (0,16,16)
      img[1,0] = ChunkyPNG::Color.rgb(12, 22, 28) # Q_16: (0,16,16)
      img[0,1] = ChunkyPNG::Color.rgb(8, 18, 25)  # Q_16: (0,16,16)
      img[1,1] = ChunkyPNG::Color.rgb(15, 25, 31) # Q_16: (0,16,16)
      img
    end

    it 'applies quantization and averages original colors for the blob' do
      # All pixels in quant_test_img quantize to (0,16,16) with interval 16.
      # So they should form a single blob.
      # The average color should be the average of their *original* colors:
      # R_avg = (10+12+8+15)/4 = 45/4 = 11 (rounded)
      # G_avg = (20+22+18+25)/4 = 85/4 = 21 (rounded)
      # B_avg = (30+28+25+31)/4 = 114/4 = 29 (rounded, 28.5) -> 29 by default round half up
      # So all pixels should be ChunkyPNG::Color.rgb(11, 21, 29)

      opts = { quant_interval: 16, min_blob_size: 0, connectivity: 4 }
      result = Impressionist.process_image(quant_test_img, opts)
      processed_img = result[:image]
      expect(result).to have_key(:labels)
      expect(result).to have_key(:blob_count)

      expected_color = ChunkyPNG::Color.rgb(11, 21, 29)
      expect(processed_img[0,0]).to eq(expected_color)
      expect(processed_img[1,0]).to eq(expected_color)
      expect(processed_img[0,1]).to eq(expected_color)
      expect(processed_img[1,1]).to eq(expected_color)
    end

    it 'applies box blur' do
      # Create a 3x3 image for blur test
      # Center pixel (1,1) = 100, neighbors = 0
      # Blur radius 1: avg over 3x3 area. (100 + 8*0)/9 = 11 (approx)
      blur_test_img = ChunkyPNG::Image.new(3, 3, ChunkyPNG::Color::BLACK) # all black
      blur_test_img[1,1] = ChunkyPNG::Color.rgb(90, 90, 90) # Center pixel bright

      opts = { blur: true, blur_radius: 1, quant_interval: 1, min_blob_size: 0 } # Quant 1 = no quantization effect
      result = Impressionist.process_image(blur_test_img, opts)
      processed_img = result[:image]
      expect(result).to have_key(:labels)
      expect(result).to have_key(:blob_count)

      # After blur, center pixel (1,1) should be average of 3x3 neighborhood.
      # (90+0*8)/9 = 10. All pixels will be (10,10,10)
      # Then it's quantized (interval 1, no change), then CCL.
      # All pixels will be one blob, averaged. The average of all pixels is (90+0*8)/9 = 10.
      # So all pixels in output should be (10,10,10).
      expect(processed_img[0,0]).to eq(ChunkyPNG::Color.rgb(10,10,10))
      expect(processed_img[1,1]).to eq(ChunkyPNG::Color.rgb(10,10,10))
      expect(processed_img[2,2]).to eq(ChunkyPNG::Color.rgb(10,10,10))
    end

    it 'handles min_blob_size by merging small blobs' do
      # Create an image with one large blob and one tiny blob (1 pixel)
      # Image: 3x1.  [L, L, S] (L=Large color, S=Small color)
      # L = (200,0,0), S = (0,200,0)
      img = ChunkyPNG::Image.new(3, 1, ChunkyPNG::Color.rgb(200,0,0))
      img[2,0] = ChunkyPNG::Color.rgb(0,200,0) # Tiny blob at (2,0)

      # quant_interval=1 means colors are taken as is for quantization step
      # min_blob_size=2 means the 1-pixel blob of S should be merged.
      # It will merge to L. So all pixels become L's average color.
      opts = { quant_interval: 1, min_blob_size: 2, connectivity: 4 }
      result = Impressionist.process_image(img, opts)
      processed_img = result[:image]
      expect(result).to have_key(:labels)
      expect(result).to have_key(:blob_count)

      # Original L pixels were (200,0,0). Original S pixel was (0,200,0).
      # After merge, all 3 pixels belong to the same blob.
      # The average color of this blob uses the *original* image colors for averaging.
      # R_avg = (200+200+0)/3 = 400/3 = 133
      # G_avg = (0+0+200)/3 = 200/3 = 67
      # B_avg = (0+0+0)/3 = 0
      # Expected color for all pixels: rgb(133, 67, 0)
      expected_color = ChunkyPNG::Color.rgb(133, 67, 0)
      expect(processed_img[0,0]).to eq(expected_color)
      expect(processed_img[1,0]).to eq(expected_color)
      expect(processed_img[2,0]).to eq(expected_color)
    end
  end

  describe '.connected_components' do
    it 'correctly labels a simple 2x2 image with 4-connectivity' do
      # Q Q
      # D D  (Q=Quantized color 1, D=Quantized color 2)
      quantized = [
        [10, 10],
        [20, 20]
      ]
      labels, count = Impressionist.send(:connected_components, quantized, 2, 2, 4)
      expect(count).to eq(2)
      expect(labels[0][0]).to eq(labels[0][1]) # Top row same blob
      expect(labels[1][0]).to eq(labels[1][1]) # Bottom row same blob
      expect(labels[0][0]).not_to eq(labels[1][0]) # Top and bottom different blobs
    end

    it 'correctly labels a diagonal with 8-connectivity vs 4-connectivity' do
      # Q D
      # D Q
      quantized = [
        [10, 20],
        [20, 10]
      ]
      # 4-connectivity: 4 blobs (each pixel is its own blob)
      labels4, count4 = Impressionist.send(:connected_components, quantized, 2, 2, 4)
      expect(count4).to eq(4)

      # 8-connectivity: 2 blobs (the two 10s form one, the two 20s form another)
      labels8, count8 = Impressionist.send(:connected_components, quantized, 2, 2, 8)
      expect(count8).to eq(2)
      expect(labels8[0][0]).to eq(labels8[1][1]) # The 10s
      expect(labels8[0][1]).to eq(labels8[1][0]) # The 20s
      expect(labels8[0][0]).not_to eq(labels8[0][1])
    end
  end

  describe '.relabel_contiguous' do
    it 're-numbers labels to be contiguous from 1' do
      # Labels from a previous step might be like:
      # 0 5 5 0
      # 5 0 0 2
      # 5 0 0 2
      # (0 is background, 5 and 2 are blob IDs)
      # This should become:
      # 0 1 1 0
      # 1 0 0 2
      # 1 0 0 2
      # (assuming 5s are one component, 2s are another)
      input_labels = [
        [0, 5, 5, 0],
        [5, 0, 0, 2],
        [5, 0, 0, 2]
      ]
      # For relabel_contiguous, it works on the basis of non-zero areas.
      # If labels[y][x] is non-zero, it's part of *some* blob.
      # It then finds connected components of these non-zero areas.
      # In the example above, all 5s are connected, all 2s are connected.
      # So it should identify two such components and label them 1 and 2.

      # The current relabel_contiguous in the provided code uses 4-connectivity
      # and original label values to determine if pixels belong to the same region.
      # Let's test it based on its actual implementation.
      # It will find connected components of pixels that had the *same original label*.

      # Scenario 1: Two distinct blobs (5 and 2)
      labels_distinct = [ [5,5,0], [0,0,2] ] # 5s are one, 2 is another
      relabeled1, count1 = Impressionist.send(:relabel_contiguous, labels_distinct, 3, 2)
      expect(count1).to eq(2)
      # Expected: [[1,1,0],[0,0,2]] (or [[2,2,0],[0,0,1]])
      blob1_val = relabeled1[0][0]
      blob2_val = relabeled1[1][2]
      expect(blob1_val).not_to eq(0)
      expect(blob2_val).not_to eq(0)
      expect(blob1_val).not_to eq(blob2_val)
      expect(relabeled1).to eq([ [blob1_val, blob1_val, 0], [0,0,blob2_val] ])


      # Scenario 2: A single blob that was fragmented then merged (all have same original label e.g. 5)
      # but are now physically separated by 0s (holes after merge_small_blobs perhaps)
      # labels_fragmented = [ [5,0,5], [0,5,0], [5,0,5] ]
      # The current relabel_contiguous will treat these as separate components if they are not
      # 4-connected based on their original label 5.
      # If all these 5s are supposed to be one final blob, the input to relabel_contiguous
      # should reflect that they are indeed connected (e.g. after merge_small_blobs fills gaps).
      # The provided relabel_contiguous's job is to make sure IDs are 1..N.

      # Test with a simple case: single blob
      labels_single = [ [7,7], [7,7] ]
      relabeled2, count2 = Impressionist.send(:relabel_contiguous, labels_single, 2, 2)
      expect(count2).to eq(1)
      expect(relabeled2).to eq([ [1,1], [1,1] ])

      # Test with holes
      labels_holes = [ [7,0,7], [0,7,0], [7,0,7] ]
      # With 4-connectivity used by relabel_contiguous's own CCL pass (when re-evaluating structure based on original labels),
      # none of these 7s are connected. So they will each get a new, distinct label.
      # The 'relabel_contiguous' processes regions that had the *same original label* if they are connected.
      # In this case, all '7's are candidates, but they are not 4-connected.
      # The UnionFind step in relabel_contiguous for `labels_holes` will result in 5 distinct sets.
      relabeled3, count3 = Impressionist.send(:relabel_contiguous, labels_holes, 3, 3)
      expect(count3).to eq(5) # Each '7' is a separate component under 4-connectivity.

      # Check that the output labels are 1,2,3,4,5 in some order for the original '7' positions
      output_labels_at_7_positions = [
        relabeled3[0][0], relabeled3[0][2],
        relabeled3[1][1],
        relabeled3[2][0], relabeled3[2][2]
      ].sort
      expect(output_labels_at_7_positions).to eq([1,2,3,4,5])

      # Ensure background is still 0
      expect(relabeled3[0][1]).to eq(0)
      expect(relabeled3[1][0]).to eq(0)
      expect(relabeled3[1][2]).to eq(0)
      expect(relabeled3[2][1]).to eq(0)
    end
  end

  # Add more focused tests for .box_blur and .merge_small_blobs if needed
  # For .box_blur, test edge cases (1x1 image, radius >= image dims).
  # For .merge_small_blobs, test complex scenarios of merging.
end

# Specific tests for Impressionist::OpenCV module
# This block will be changed to Impressionist::MatzEye
RSpec.describe Impressionist::MatzEye do
  let(:fixture_dir) { File.expand_path('../../fixtures', __FILE__) }
  let(:input_path) { File.join(fixture_dir, 'test_image.png') } # 1x1 transparent PNG
  let(:larger_input_path) { File.join(fixture_dir, 'sample_image.png') } # A slightly larger image for more robust tests

  # Helper to create a simple checksum for a ChunkyPNG image
  def image_checksum(chunky_image)
    sum = 0
    chunky_image.pixels.each { |p| sum += p }
    sum
  end

  before(:all) do
    # Create a slightly larger fixture if it doesn't exist (e.g., 5x5)
    # This helps in testing blur, min_blob_size etc. more meaningfully.
    sample_png_path = File.join(File.expand_path('../../fixtures', __FILE__), 'sample_image.png')
    unless File.exist?(sample_png_path)
      FileUtils.mkdir_p(File.dirname(sample_png_path))
      img = ChunkyPNG::Image.new(5, 5, ChunkyPNG::Color::WHITE)
      img[0,0] = ChunkyPNG::Color::BLACK
      img[1,1] = ChunkyPNG::Color.rgb(10,20,30)
      img[2,2] = ChunkyPNG::Color.rgb(30,20,10)
      img[3,3] = ChunkyPNG::Color.rgb(50,50,50)
      img[4,4] = ChunkyPNG::Color.rgb(100,100,100)
      img[0,4] = ChunkyPNG::Color.rgb(0,0,255) # A distinct color patch
      img.save(sample_png_path)
    end
  end


  describe '.process_image' do
    let(:source_chunky_image) { ChunkyPNG::Image.from_file(input_path) }
    let(:larger_chunky_image) { ChunkyPNG::Image.from_file(larger_input_path) }

    describe '.box_blur' do
      it 'correctly blurs a simple 3x3 image with radius 1' do
        img = ChunkyPNG::Image.new(3, 3, ChunkyPNG::Color::TRANSPARENT)
        # Define a simple pattern:
        # 0  0  0
        # 0 90  0
        # 0  0  0
        # All RGB components are the same for simplicity in manual calculation
        img[1,1] = ChunkyPNG::Color.rgb(90,90,90)
        # Expected:
        # 10 20 10
        # 20 30 20
        # 10 20 10
        # (0,0): (0*4 + 90)/9 = 10
        # (1,0): (0*6 + 90)/9 = 10 -> (0*5 + 90*1)/9 = 10 (mistake in manual calc, should be sum of neighbors)
        # Corrected manual calculation for (1,0) with radius 1:
        # Neighbors of (1,0): (0,0),(1,0),(2,0), (0,1),(1,1),(2,1) -> all 0 except (1,1)=90
        # (0*5 + 90)/6 = 15
        # (0,0) -> (0*3 + 90 (from 1,1) ) / 4 = 22 (approx) (0,0) (1,0) (0,1) (1,1)
        # Let's use the provided ruby implementation logic for expectation:
        # Center (1,1): (90 * 1 + 0 * 8) / 9 = 10
        # Edge (1,0): (90 * 1 + 0 * 5) / 6 = 15
        # Corner (0,0): (90 * 1 + 0 * 3) / 4 = 22 (rounded from 22.5)

        blurred_img = Impressionist::MatzEye.box_blur(img, 1)
        expect(blurred_img.width).to eq(3)
        expect(blurred_img.height).to eq(3)

        expect(blurred_img[0,0]).to eq(ChunkyPNG::Color.rgb(23,23,23)) # (90/4) = 22.5 -> 23
        expect(blurred_img[1,0]).to eq(ChunkyPNG::Color.rgb(15,15,15)) # (90/6) = 15
        expect(blurred_img[0,1]).to eq(ChunkyPNG::Color.rgb(15,15,15)) # (90/6) = 15
        expect(blurred_img[1,1]).to eq(ChunkyPNG::Color.rgb(10,10,10)) # (90/9) = 10
      end

      it 'handles radius 0 (effectively radius 1)' do
        img = ChunkyPNG::Image.new(2,2, ChunkyPNG::Color.rgb(100,100,100))
        img[0,0] = ChunkyPNG::Color.rgb(0,0,0)
        # (0,0) with radius 1: (0*1 + 100*3)/4 = 75
        blurred_img_r0 = Impressionist::MatzEye.box_blur(img, 0)
        blurred_img_r1 = Impressionist::MatzEye.box_blur(img, 1)
        expect(blurred_img_r0[0,0]).to eq(ChunkyPNG::Color.rgb(75,75,75))
        expect(blurred_img_r0).to eq(blurred_img_r1)
      end

      it 'handles image smaller than radius correctly' do
        img = ChunkyPNG::Image.new(2,2)
        img[0,0] = ChunkyPNG::Color.rgb(0,0,0)
        img[0,1] = ChunkyPNG::Color.rgb(50,50,50)
        img[1,0] = ChunkyPNG::Color.rgb(100,100,100)
        img[1,1] = ChunkyPNG::Color.rgb(200,200,200)
        # Avg R = (0+50+100+200)/4 = 350/4 = 87.5 -> 88
        # All pixels should be this average color if radius is large (e.g., 5)
        avg_val = ((0+50+100+200)/4.0).round
        expected_color = ChunkyPNG::Color.rgb(avg_val, avg_val, avg_val)

        blurred_img = Impressionist::MatzEye.box_blur(img, 5)
        expect(blurred_img[0,0]).to eq(expected_color)
        expect(blurred_img[0,1]).to eq(expected_color)
        expect(blurred_img[1,0]).to eq(expected_color)
        expect(blurred_img[1,1]).to eq(expected_color)
      end
    end

    describe '.quantize_image' do
      it 'quantizes colors correctly with a given interval' do
        img = ChunkyPNG::Image.new(1, 1, ChunkyPNG::Color.rgba(35, 67, 99, 128)) # r,g,b,a
        # Interval 32:
        # R: (35/32)*32 = 1*32 = 32
        # G: (67/32)*32 = 2*32 = 64
        # B: (99/32)*32 = 3*32 = 96
        # A: 128 (preserved)
        quantized_img = Impressionist::MatzEye.quantize_image(img, 32)
        expect(quantized_img.width).to eq(1)
        expect(quantized_img.height).to eq(1)
        expect(ChunkyPNG::Color.r(quantized_img[0,0])).to eq(32)
        expect(ChunkyPNG::Color.g(quantized_img[0,0])).to eq(64)
        expect(ChunkyPNG::Color.b(quantized_img[0,0])).to eq(96)
        expect(ChunkyPNG::Color.a(quantized_img[0,0])).to eq(128) # Alpha preserved
      end

      it 'quantizes with interval 64' do
        img = ChunkyPNG::Image.new(1, 1, ChunkyPNG::Color.rgb(35, 67, 99))
        # Interval 64:
        # R: (35/64)*64 = 0*64 = 0
        # G: (67/64)*64 = 1*64 = 64
        # B: (99/64)*64 = 1*64 = 64
        quantized_img = Impressionist::MatzEye.quantize_image(img, 64)
        expect(quantized_img[0,0]).to eq(ChunkyPNG::Color.rgb(0, 64, 64))
      end

      it 'quantizes with interval 1 (no change to RGB)' do
        original_color = ChunkyPNG::Color.rgba(35, 67, 99, 200)
        img = ChunkyPNG::Image.new(1, 1, original_color)
        quantized_img = Impressionist::MatzEye.quantize_image(img, 1)
        expect(ChunkyPNG::Color.r(quantized_img[0,0])).to eq(35)
        expect(ChunkyPNG::Color.g(quantized_img[0,0])).to eq(67)
        expect(ChunkyPNG::Color.b(quantized_img[0,0])).to eq(99)
        expect(ChunkyPNG::Color.a(quantized_img[0,0])).to eq(200) # Alpha preserved
      end
    end

    describe '.perform_ccl' do
      # Helper to create packed RGB integer
      def pack_rgb(r,g,b)
        (r << 16) | (g << 8) | b
      end

      let(:color1) { pack_rgb(10,20,30) }
      let(:color2) { pack_rgb(50,60,70) }
      let(:color3) { pack_rgb(100,110,120) }

      it 'labels a single blob image' do
        data = [
          [color1, color1, color1],
          [color1, color1, color1],
          [color1, color1, color1]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(1)
        expect(labels.flatten.uniq).to eq([1]) # All pixels should have label 1
      end

      it 'labels two distinct non-touching blobs (different colors)' do
        data = [
          [color1, color1, 0],
          [color1, color1, 0],
          [0,      0,      color2]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(2)
        expect(labels[0][0]).to eq(1)
        expect(labels[1][1]).to eq(1)
        expect(labels[2][2]).to eq(2)
      end

      it 'labels two distinct non-touching blobs (same color)' do
        data = [
          [color1, color1, 0],
          [color1, color1, 0],
          [0,      0,      color1] # Same color as first blob, but not connected
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(2) # Should be 2 distinct blobs
        expect(labels[0][0]).to eq(1)
        expect(labels[2][2]).to eq(2) # Different label
      end

      it 'labels two touching blobs (same color) as one blob' do
        data = [
          [color1, color1, 0],
          [0,      color1, color1],
          [0,      0,      color1]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(1)
        expect(labels[0][0]).to eq(1)
        expect(labels[1][2]).to eq(1)
      end

      it 'labels two touching blobs (different colors) as two blobs' do
        data = [
          [color1, color1, 0],
          [0,      color1, color2], # color1 and color2 touch here
          [0,      0,      color2]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(2)
        expect(labels[0][0]).to eq(1) # Part of blob 1
        expect(labels[1][1]).to eq(1) # Part of blob 1
        expect(labels[1][2]).to eq(2) # Part of blob 2
        expect(labels[2][2]).to eq(2) # Part of blob 2
      end

      it 'handles 4-connectivity for diagonal elements' do
        data = [
          [color1, 0,      0],
          [0,      color1, 0],
          [0,      0,      color1]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 4)
        expect(count).to eq(3) # Each is a separate blob
      end

      it 'handles 8-connectivity for diagonal elements' do
        data = [
          [color1, 0,      0],
          [0,      color1, 0],
          [0,      0,      color1]
        ]
        labels, count = Impressionist::MatzEye.perform_ccl(data, 3, 3, 8)
        expect(count).to eq(1) # All connected due to 8-way
        expect(labels[0][0]).to eq(1)
        expect(labels[1][1]).to eq(1)
        expect(labels[2][2]).to eq(1)
      end
    end

    describe '.filter_and_relabel_blobs' do
      it 'filters small blobs and relabels contiguously' do
        # Blob 1 (size 4), Blob 2 (size 2), Blob 3 (size 3)
        labels_array = [
          [1, 1, 0, 2, 2],
          [1, 1, 0, 3, 0],
          [0, 0, 0, 3, 3]
        ]
        # Filter blobs smaller than 3 (i.e., remove Blob 2)
        # Blob 1 remains, Blob 3 remains. They should be relabeled to 1 and 2.
        filtered_labels, new_count = Impressionist::MatzEye.filter_and_relabel_blobs(labels_array, 5, 3, 3)

        expect(new_count).to eq(2)
        # Check that blob 2 is gone (pixels are 0)
        expect(filtered_labels[0][3]).to eq(0)
        expect(filtered_labels[0][4]).to eq(0)
        # Check that blob 1 is now label 1 (or 2)
        expect(filtered_labels[0][0]).to satisfy { |x| x == 1 || x == 2 }
        # Check that blob 3 is now the other label
        expect(filtered_labels[1][3]).to satisfy { |x| x == 1 || x == 2 }
        expect(filtered_labels[0][0]).not_to eq(filtered_labels[1][3]) # Ensure they are different new labels

        # Verify all old blob 2 pixels are 0
        expect(filtered_labels.flatten.count(0)).to eq( (5*3) - 4 - 3) # Total - size_blob1 - size_blob3
      end

      it 'filters all blobs if they are too small' do
        labels_array = [
          [1, 0, 2, 2],
          [0, 0, 0, 2]
        ] # Blob 1 (size 1), Blob 2 (size 3)
        filtered_labels, new_count = Impressionist::MatzEye.filter_and_relabel_blobs(labels_array, 4, 2, 4)
        expect(new_count).to eq(0)
        expect(filtered_labels.flatten.all?(&:zero?)).to be true
      end

      it 'does not filter if min_size is 0 or 1 and relabels if needed' do
        labels_array = [ # Blob 5 (size 2), Blob 2 (size 1) - non-contiguous
          [5, 5, 0],
          [0, 2, 0]
        ]
        filtered_labels, new_count = Impressionist::MatzEye.filter_and_relabel_blobs(labels_array, 3, 2, 1)
        expect(new_count).to eq(2)
        # Expect labels to be 1 and 2
        expect(filtered_labels[0][0]).to eq(1) # Old 5 becomes 1
        expect(filtered_labels[0][1]).to eq(1)
        expect(filtered_labels[1][1]).to eq(2) # Old 2 becomes 2
      end

      it 'maintains contiguity if no blobs are filtered' do
         labels_array = [ # Blob 1 (size 2), Blob 2 (size 1) - already contiguous
          [1, 1, 0],
          [0, 2, 0]
        ]
        filtered_labels, new_count = Impressionist::MatzEye.filter_and_relabel_blobs(labels_array, 3, 2, 1)
        expect(new_count).to eq(2)
        expect(filtered_labels).to eq(labels_array) # Should be identical
      end
    end

    describe '.calculate_average_colors' do
      let(:source_image_2x2) do
        img = ChunkyPNG::Image.new(2, 2)
        img[0,0] = ChunkyPNG::Color.rgb(10,20,30)
        img[1,0] = ChunkyPNG::Color.rgb(50,60,70) # Part of blob 1 in some tests
        img[0,1] = ChunkyPNG::Color.rgb(100,0,0) # Part of blob 2
        img[1,1] = ChunkyPNG::Color.rgb(0,100,0) # Part of blob 2
        img
      end

      it 'calculates average for a single blob covering whole image' do
        labels = [[1,1],[1,1]]
        avg_map = Impressionist::MatzEye.calculate_average_colors(source_image_2x2, labels, 2, 2, 1)
        # R_avg = (10+50+100+0)/4 = 160/4 = 40
        # G_avg = (20+60+0+100)/4 = 180/4 = 45
        # B_avg = (30+70+0+0)/4 = 100/4 = 25
        expect(avg_map[1]).to eq([40,45,25])
      end

      it 'calculates averages for multiple distinct blobs' do
        labels = [[1,1],[0,2]] # Blob 1: (0,0), (1,0). Blob 2: (1,1)
        avg_map = Impressionist::MatzEye.calculate_average_colors(source_image_2x2, labels, 2, 2, 2)
        # Blob 1: R=(10+50)/2=30, G=(20+60)/2=40, B=(30+70)/2=50
        expect(avg_map[1]).to eq([30,40,50])
        # Blob 2: R=0, G=100, B=0
        expect(avg_map[2]).to eq([0,100,0])
      end

      it 'handles blob_count correctly if a label ID has no pixels' do
        labels = [[1,1],[0,0]] # Blob 1 exists, Blob 2 (implied by blob_count=2) does not
        avg_map = Impressionist::MatzEye.calculate_average_colors(source_image_2x2, labels, 2, 2, 2)
        expect(avg_map[1]).to eq([30,40,50]) # Average of (0,0) and (1,0)
        expect(avg_map[2]).to eq([0,0,0])   # Default for blob with no pixels
      end

      it 'returns an empty map if blob_count is 0' do
        labels = [[0,0],[0,0]]
        avg_map = Impressionist::MatzEye.calculate_average_colors(source_image_2x2, labels, 2, 2, 0)
        expect(avg_map).to be_empty
      end
    end

    describe '.build_recolored_image' do
      it 'constructs the output image from labels and average colors' do
        labels = [
          [1, 1, 0],
          [0, 2, 2]
        ]
        avg_colors = {
          1 => [255,0,0], # Red
          2 => [0,0,255]  # Blue
        }
        width = 3
        height = 2

        output_image = Impressionist::MatzEye.build_recolored_image(labels, avg_colors, width, height)

        expect(output_image.width).to eq(width)
        expect(output_image.height).to eq(height)

        expect(output_image[0,0]).to eq(ChunkyPNG::Color.rgb(255,0,0))
        expect(output_image[1,0]).to eq(ChunkyPNG::Color.rgb(255,0,0))
        expect(output_image[2,0]).to eq(ChunkyPNG::Color::WHITE) # Background
        expect(output_image[0,1]).to eq(ChunkyPNG::Color::WHITE) # Background
        expect(output_image[1,1]).to eq(ChunkyPNG::Color.rgb(0,0,255))
        expect(output_image[2,1]).to eq(ChunkyPNG::Color.rgb(0,0,255))
      end

      it 'handles labels not present in average_colors_map by using background' do
        labels = [[1,2]] # Label 2 has no avg color defined
        avg_colors = { 1 => [100,100,100] }
        output_image = Impressionist::MatzEye.build_recolored_image(labels, avg_colors, 2, 1)
        expect(output_image[0,0]).to eq(ChunkyPNG::Color.rgb(100,100,100))
        expect(output_image[1,0]).to eq(ChunkyPNG::Color::WHITE) # Background
      end
    end

    # These tests for process_image will be adapted or removed if they
    # were specifically testing OpenCV features not yet in MatzEye pure Ruby.
    # For now, they will fail because MatzEye.process_image raises NotImplementedError
    # or only implements blur.
    # The subtask asks to integrate box_blur, so we'll modify process_image
    # to use it and return the blurred image for now.
    it 'processes a basic image (blur only) and returns the correct structure' do
      opts = { implementation: :matzeye, blur: true, blur_radius: 1 }
      # Now process_image is expected to run blur then quantize, then try CCL.
      # The test for just blur needs to be more specific or process_image needs to be
      # testable for intermediate steps. For now, this test will reflect the current
      # state of process_image.
      result = Impressionist::MatzEye.process_image(larger_chunky_image, opts)

      expect(result).to be_a(Hash)
      expect(result).to have_key(:image) # This will be the blurred image
      # Labels and blob_count will be placeholders from the modified process_image
      expect(result[:labels]).to be_an(Array) # Still placeholder
      expect(result[:blob_count]).to be_an(Integer) # Still placeholder

      # Verify the blurred image is different from original if blur was applied
      original_checksum = image_checksum(larger_chunky_image)
      blurred_checksum = image_checksum(result[:image])
      expect(blurred_checksum).not_to eq(original_checksum)
    end

    it 'processes a basic image (no blur) and returns the correct structure' do
      opts = { implementation: :matzeye, blur: false }
      result = Impressionist::MatzEye.process_image(larger_chunky_image, opts)

      expect(result).to be_a(Hash)
      expect(result[:image]).to be_a(ChunkyPNG::Image)
      expect(result[:image].width).to eq(larger_chunky_image.width)
      expect(result[:image].height).to eq(larger_chunky_image.height)

      # Verify the image is a (deep) copy of the original, and quantized with default interval
      expect(result[:image]).not_to be(larger_chunky_image)

      # Manually calculate expected quantized image with default interval (16)
      expected_quantized_image = Impressionist::MatzEye.quantize_image(larger_chunky_image, 16)

      expect(result[:image]).to eq(expected_quantized_image)
    end

    # The following tests for min_blob_size and quant_interval will fail (or currently do)
    # as MatzEye.process_image is now fully implemented in pure Ruby.
    context 'with options' do
      it 'handles :min_blob_size correctly' do
        opts_no_filter = { min_blob_size: 0 } # Or 1, as 0 effectively means no filtering
        opts_with_filter = { min_blob_size: 5 } # Assuming sample_image might have small blobs

        result_no_filter = Impressionist::MatzEye.process_image(larger_chunky_image, opts_no_filter)
        result_with_filter = Impressionist::MatzEye.process_image(larger_chunky_image, opts_with_filter)

        expect(result_no_filter[:blob_count]).to be >= result_with_filter[:blob_count]
        # Could also compare image checksums if a visual difference is expected
        # expect(image_checksum(result_no_filter[:image])).not_to eq(image_checksum(result_with_filter[:image]))
        # This depends on sample_image.png having blobs that would actually be filtered by min_blob_size: 5
      end

      it 'produces different images with different :quant_interval values' do
        opts_quant_low = { quant_interval: 8 } # Default is 16, use something different
        opts_quant_high = { quant_interval: 64 }

        result_quant_low = Impressionist::MatzEye.process_image(larger_chunky_image, opts_quant_low)
        result_quant_high = Impressionist::MatzEye.process_image(larger_chunky_image, opts_quant_high)

        checksum_low = image_checksum(result_quant_low[:image])
        checksum_high = image_checksum(result_quant_high[:image])
        expect(checksum_low).not_to eq(checksum_high)
      end
    end
  end
end
