require 'spec_helper'
require 'chunky_png'
require 'impressionist' # Assuming lib is in $LOAD_PATH via spec_helper

RSpec.describe Impressionist do
  let(:fixture_dir) { File.expand_path('../../fixtures', __FILE__) }
  let(:input_path) { File.join(fixture_dir, 'test_image.png') } # Using the 1x1 PNG from previous step
  let(:output_dir) { File.expand_path('../../../tmp/test_output', __FILE__) } # Temp output for this spec
  let(:output_path) { File.join(output_dir, 'output_impressionist.png') }

  before(:all) do
    # Ensure fixture_image.png exists (it's a 1x1 transparent PNG)
    # This should have been created by the app_integration_spec setup, but ensure it for standalone runs.
    fixture_png_path = File.join(File.expand_path('../../fixtures', __FILE__), 'test_image.png')
    unless File.exist?(fixture_png_path)
      FileUtils.mkdir_p(File.dirname(fixture_png_path))
      File.open(fixture_png_path, 'wb') do |f|
        f.write(Base64.decode64('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='))
      end
    end
  end

  before(:each) do
    FileUtils.mkdir_p(output_dir)
    FileUtils.rm_f(output_path) # Clean up output file before each test
  end

  after(:all) do
    FileUtils.rm_rf(File.expand_path('../../../tmp', __FILE__)) # Clean up all tmp content generated by specs
  end

  describe '.load_image' do
    it 'loads a PNG file' do
      expect { Impressionist.load_image(input_path) }.not_to raise_error
      img = Impressionist.load_image(input_path)
      expect(img).to be_a(ChunkyPNG::Image)
      expect(img.width).to eq(1)
      expect(img.height).to eq(1)
    end

    it 'raises an error if file not found' do
      expect { Impressionist.load_image('nonexistent.png') }.to raise_error(ArgumentError, /File not found/)
    end
  end

  describe '.save_image' do
    it 'saves a ChunkyPNG::Image to disk' do
      img = ChunkyPNG::Image.new(1, 1, ChunkyPNG::Color::BLACK)
      Impressionist.save_image(img, output_path)
      expect(File.exist?(output_path)).to be true
      loaded_img = ChunkyPNG::Image.from_file(output_path)
      expect(loaded_img[0,0]).to eq(ChunkyPNG::Color::BLACK)
    end
  end

  describe '.recolor' do
    it 'processes an image and saves it' do
      options = { quant_interval: 8 }
      expect(Impressionist.recolor(input_path, output_path, options)).to be true
      expect(File.exist?(output_path)).to be true
      # Basic check, more detailed checks in .process_image specs
      expect(ChunkyPNG::Image.from_file(output_path)).to be_a(ChunkyPNG::Image)
    end
  end

  describe '.process' do
    it 'processes an image and returns a ChunkyPNG::Image' do
      options = { quant_interval: 8 }
      img = Impressionist.process(input_path, options)
      expect(img).to be_a(ChunkyPNG::Image)
      # More detailed checks in .process_image specs
    end
  end

  describe '.process_image' do
    let(:source_img) { ChunkyPNG::Image.new(2, 2, ChunkyPNG::Color.rgb(100, 150, 200)) }
    # For quantization test, use pixels that will quantize to the SAME color
    # to ensure a single blob, then check if the average of ORIGINALS is used.
    let(:quant_test_img) do
      img = ChunkyPNG::Image.new(2, 2)
      img[0,0] = ChunkyPNG::Color.rgb(10, 20, 30) # Q_16: (0,16,16)
      img[1,0] = ChunkyPNG::Color.rgb(12, 22, 28) # Q_16: (0,16,16)
      img[0,1] = ChunkyPNG::Color.rgb(8, 18, 25)  # Q_16: (0,16,16)
      img[1,1] = ChunkyPNG::Color.rgb(15, 25, 31) # Q_16: (0,16,16)
      img
    end

    it 'applies quantization and averages original colors for the blob' do
      # All pixels in quant_test_img quantize to (0,16,16) with interval 16.
      # So they should form a single blob.
      # The average color should be the average of their *original* colors:
      # R_avg = (10+12+8+15)/4 = 45/4 = 11 (rounded)
      # G_avg = (20+22+18+25)/4 = 85/4 = 21 (rounded)
      # B_avg = (30+28+25+31)/4 = 114/4 = 29 (rounded, 28.5) -> 29 by default round half up
      # So all pixels should be ChunkyPNG::Color.rgb(11, 21, 29)

      opts = { quant_interval: 16, min_blob_size: 0, connectivity: 4 }
      processed_img = Impressionist.process_image(quant_test_img, opts)

      expected_color = ChunkyPNG::Color.rgb(11, 21, 29)
      expect(processed_img[0,0]).to eq(expected_color)
      expect(processed_img[1,0]).to eq(expected_color)
      expect(processed_img[0,1]).to eq(expected_color)
      expect(processed_img[1,1]).to eq(expected_color)
    end

    it 'applies box blur' do
      # Create a 3x3 image for blur test
      # Center pixel (1,1) = 100, neighbors = 0
      # Blur radius 1: avg over 3x3 area. (100 + 8*0)/9 = 11 (approx)
      blur_test_img = ChunkyPNG::Image.new(3, 3, ChunkyPNG::Color::BLACK) # all black
      blur_test_img[1,1] = ChunkyPNG::Color.rgb(90, 90, 90) # Center pixel bright

      opts = { blur: true, blur_radius: 1, quant_interval: 1, min_blob_size: 0 } # Quant 1 = no quantization effect
      processed_img = Impressionist.process_image(blur_test_img, opts)

      # After blur, center pixel (1,1) should be average of 3x3 neighborhood.
      # (90+0*8)/9 = 10. All pixels will be (10,10,10)
      # Then it's quantized (interval 1, no change), then CCL.
      # All pixels will be one blob, averaged. The average of all pixels is (90+0*8)/9 = 10.
      # So all pixels in output should be (10,10,10).
      expect(processed_img[0,0]).to eq(ChunkyPNG::Color.rgb(10,10,10))
      expect(processed_img[1,1]).to eq(ChunkyPNG::Color.rgb(10,10,10))
      expect(processed_img[2,2]).to eq(ChunkyPNG::Color.rgb(10,10,10))
    end

    it 'handles min_blob_size by merging small blobs' do
      # Create an image with one large blob and one tiny blob (1 pixel)
      # Image: 3x1.  [L, L, S] (L=Large color, S=Small color)
      # L = (200,0,0), S = (0,200,0)
      img = ChunkyPNG::Image.new(3, 1, ChunkyPNG::Color.rgb(200,0,0))
      img[2,0] = ChunkyPNG::Color.rgb(0,200,0) # Tiny blob at (2,0)

      # quant_interval=1 means colors are taken as is for quantization step
      # min_blob_size=2 means the 1-pixel blob of S should be merged.
      # It will merge to L. So all pixels become L's average color.
      opts = { quant_interval: 1, min_blob_size: 2, connectivity: 4 }
      processed_img = Impressionist.process_image(img, opts)

      # Original L pixels were (200,0,0). Original S pixel was (0,200,0).
      # After merge, all 3 pixels belong to the same blob.
      # The average color of this blob uses the *original* image colors for averaging.
      # R_avg = (200+200+0)/3 = 400/3 = 133
      # G_avg = (0+0+200)/3 = 200/3 = 67
      # B_avg = (0+0+0)/3 = 0
      # Expected color for all pixels: rgb(133, 67, 0)
      expected_color = ChunkyPNG::Color.rgb(133, 67, 0)
      expect(processed_img[0,0]).to eq(expected_color)
      expect(processed_img[1,0]).to eq(expected_color)
      expect(processed_img[2,0]).to eq(expected_color)
    end
  end

  describe '.connected_components' do
    it 'correctly labels a simple 2x2 image with 4-connectivity' do
      # Q Q
      # D D  (Q=Quantized color 1, D=Quantized color 2)
      quantized = [
        [10, 10],
        [20, 20]
      ]
      labels, count = Impressionist.send(:connected_components, quantized, 2, 2, 4)
      expect(count).to eq(2)
      expect(labels[0][0]).to eq(labels[0][1]) # Top row same blob
      expect(labels[1][0]).to eq(labels[1][1]) # Bottom row same blob
      expect(labels[0][0]).not_to eq(labels[1][0]) # Top and bottom different blobs
    end

    it 'correctly labels a diagonal with 8-connectivity vs 4-connectivity' do
      # Q D
      # D Q
      quantized = [
        [10, 20],
        [20, 10]
      ]
      # 4-connectivity: 4 blobs (each pixel is its own blob)
      labels4, count4 = Impressionist.send(:connected_components, quantized, 2, 2, 4)
      expect(count4).to eq(4)

      # 8-connectivity: 2 blobs (the two 10s form one, the two 20s form another)
      labels8, count8 = Impressionist.send(:connected_components, quantized, 2, 2, 8)
      expect(count8).to eq(2)
      expect(labels8[0][0]).to eq(labels8[1][1]) # The 10s
      expect(labels8[0][1]).to eq(labels8[1][0]) # The 20s
      expect(labels8[0][0]).not_to eq(labels8[0][1])
    end
  end

  describe '.relabel_contiguous' do
    it 're-numbers labels to be contiguous from 1' do
      # Labels from a previous step might be like:
      # 0 5 5 0
      # 5 0 0 2
      # 5 0 0 2
      # (0 is background, 5 and 2 are blob IDs)
      # This should become:
      # 0 1 1 0
      # 1 0 0 2
      # 1 0 0 2
      # (assuming 5s are one component, 2s are another)
      input_labels = [
        [0, 5, 5, 0],
        [5, 0, 0, 2],
        [5, 0, 0, 2]
      ]
      # For relabel_contiguous, it works on the basis of non-zero areas.
      # If labels[y][x] is non-zero, it's part of *some* blob.
      # It then finds connected components of these non-zero areas.
      # In the example above, all 5s are connected, all 2s are connected.
      # So it should identify two such components and label them 1 and 2.

      # The current relabel_contiguous in the provided code uses 4-connectivity
      # and original label values to determine if pixels belong to the same region.
      # Let's test it based on its actual implementation.
      # It will find connected components of pixels that had the *same original label*.

      # Scenario 1: Two distinct blobs (5 and 2)
      labels_distinct = [ [5,5,0], [0,0,2] ] # 5s are one, 2 is another
      relabeled1, count1 = Impressionist.send(:relabel_contiguous, labels_distinct, 3, 2)
      expect(count1).to eq(2)
      # Expected: [[1,1,0],[0,0,2]] (or [[2,2,0],[0,0,1]])
      blob1_val = relabeled1[0][0]
      blob2_val = relabeled1[1][2]
      expect(blob1_val).not_to eq(0)
      expect(blob2_val).not_to eq(0)
      expect(blob1_val).not_to eq(blob2_val)
      expect(relabeled1).to eq([ [blob1_val, blob1_val, 0], [0,0,blob2_val] ])


      # Scenario 2: A single blob that was fragmented then merged (all have same original label e.g. 5)
      # but are now physically separated by 0s (holes after merge_small_blobs perhaps)
      # labels_fragmented = [ [5,0,5], [0,5,0], [5,0,5] ]
      # The current relabel_contiguous will treat these as separate components if they are not
      # 4-connected based on their original label 5.
      # If all these 5s are supposed to be one final blob, the input to relabel_contiguous
      # should reflect that they are indeed connected (e.g. after merge_small_blobs fills gaps).
      # The provided relabel_contiguous's job is to make sure IDs are 1..N.

      # Test with a simple case: single blob
      labels_single = [ [7,7], [7,7] ]
      relabeled2, count2 = Impressionist.send(:relabel_contiguous, labels_single, 2, 2)
      expect(count2).to eq(1)
      expect(relabeled2).to eq([ [1,1], [1,1] ])

      # Test with holes
      labels_holes = [ [7,0,7], [0,7,0], [7,0,7] ]
      # With 4-connectivity used by relabel_contiguous's own CCL pass (when re-evaluating structure based on original labels),
      # none of these 7s are connected. So they will each get a new, distinct label.
      # The 'relabel_contiguous' processes regions that had the *same original label* if they are connected.
      # In this case, all '7's are candidates, but they are not 4-connected.
      # The UnionFind step in relabel_contiguous for `labels_holes` will result in 5 distinct sets.
      relabeled3, count3 = Impressionist.send(:relabel_contiguous, labels_holes, 3, 3)
      expect(count3).to eq(5) # Each '7' is a separate component under 4-connectivity.

      # Check that the output labels are 1,2,3,4,5 in some order for the original '7' positions
      output_labels_at_7_positions = [
        relabeled3[0][0], relabeled3[0][2],
        relabeled3[1][1],
        relabeled3[2][0], relabeled3[2][2]
      ].sort
      expect(output_labels_at_7_positions).to eq([1,2,3,4,5])

      # Ensure background is still 0
      expect(relabeled3[0][1]).to eq(0)
      expect(relabeled3[1][0]).to eq(0)
      expect(relabeled3[1][2]).to eq(0)
      expect(relabeled3[2][1]).to eq(0)
    end
  end

  # Add more focused tests for .box_blur and .merge_small_blobs if needed
  # For .box_blur, test edge cases (1x1 image, radius >= image dims).
  # For .merge_small_blobs, test complex scenarios of merging.
end
